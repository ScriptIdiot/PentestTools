#include "addresshunter.h"
#include "definitions.h"



// kernel32.dll exports
typedef HLOCAL(WINAPI* LOCALFREE)(HLOCAL);
typedef HMODULE(WINAPI* LOADLIBRARYA)(LPCSTR);

// msvcrt.dll exports
typedef int(WINAPI* WPRINTF)(const wchar_t* format, ...);
typedef int(WINAPI* PRINTF)(const char* format, ...);
typedef void*(WINAPI* CALLOC)(size_t num, size_t size);
typedef void*(WINAPI* MEMCPY)(void*, const void*, size_t);


// Ws2_32.dll exports
typedef char*(WINAPI* INETNTOA)(IN_ADDR in);
typedef const char*(WINAPI* INETNTOP)(int, const void*, char*, size_t);

// Dnsapi.dll exports
typedef DNS_STATUS(WINAPI* DNSQUERY_W)(PCWSTR,WORD,DWORD,PVOID,PDNS_RECORD *,PVOID *);
typedef void(WINAPI* DNSRECORDLISTFREE)(PDNS_RECORD, DNS_FREE_TYPE);
typedef int(WINAPI* DNSGETCACHEDATATABLE)(PDNS_CACHE_ENTRY);




//https://stackoverflow.com/questions/31889957/memory-leak-when-using-dnsgetcachedatatable
void dnscache()
{
    UINT64 kernel32dll, msvcrtdll, dnsapidll,  ws2_32dll;
    UINT64 LoadLibraryAFunc, memcpyFunc, inet_ntoaFunc, inet_ntopFunc, printfFunc, dnsgetcachedatatableFunc, callocFunc, dnsquery_wFunc, dnsrecordlistfreeFunc ;

    // kernel32.dll exports

    kernel32dll = GetKernel32();

    char loadlibrarya_c[] = {'L', 'o', 'a', 'd', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'A', 0};
    LoadLibraryAFunc = GetSymbolAddress((HANDLE)kernel32dll, loadlibrarya_c);


    //msvcrt.dll exports

    char msvcrt_c[] = {'m', 's', 'v', 'c', 'r', 't', '.', 'd', 'l', 'l', 0};
    msvcrtdll = (UINT64) ((LOADLIBRARYA)LoadLibraryAFunc)(msvcrt_c);

    char printf_c[] = {'p', 'r', 'i', 'n', 't', 'f', 0};
    printfFunc = GetSymbolAddress((HANDLE)msvcrtdll, printf_c);

    char calloc_c[] = { 'c', 'a', 'l', 'l', 'o', 'c', 0 };
    callocFunc = GetSymbolAddress((HANDLE)msvcrtdll, calloc_c);

    char memcpy_c[] = { 'm', 'e', 'm', 'c', 'p', 'y', 0 };
    memcpyFunc = GetSymbolAddress((HANDLE)msvcrtdll, memcpy_c);


    // Dnsapi.dll exports

    char dnsapi_c[] = { 'D', 'n', 's', 'a', 'p', 'i', '.', 'd', 'l', 'l', 0 };
    dnsapidll = (UINT64) ((LOADLIBRARYA)LoadLibraryAFunc)(dnsapi_c);

    char dnsgetcachedatatable_c[] = { 'D', 'n', 's', 'G', 'e', 't', 'C', 'a', 'c', 'h', 'e', 'D', 'a', 't', 'a', 'T', 'a', 'b', 'l', 'e', 0 };
    dnsgetcachedatatableFunc = GetSymbolAddress((HANDLE)dnsapidll, dnsgetcachedatatable_c);

    char dnsquery_w_c[] = { 'D', 'n', 's', 'Q', 'u', 'e', 'r', 'y', '_', 'W', 0 };
    dnsquery_wFunc = GetSymbolAddress((HANDLE)dnsapidll, dnsquery_w_c);

    char dnsrecordlistfree_c[] = { 'D', 'n', 's', 'R', 'e', 'c', 'o', 'r', 'd', 'L', 'i', 's', 't', 'F', 'r', 'e', 'e', 0 };
    dnsrecordlistfreeFunc = GetSymbolAddress((HANDLE)dnsapidll, dnsrecordlistfree_c);


    // Ws2_32.dll exports

    char ws2_32_c[] = { 'W', 's', '2', '_', '3', '2', '.', 'd', 'l', 'l', 0 };
    ws2_32dll = (UINT64) ((LOADLIBRARYA)LoadLibraryAFunc)(ws2_32_c);
    
    char inettoa_c[] = { 'i', 'n', 'e', 't', '_', 'n', 't', 'o', 'a', 0 };
    inet_ntoaFunc = GetSymbolAddress((HANDLE)ws2_32dll, inettoa_c);

    char inet_ntop_c[] = { 'i', 'n', 'e', 't', '_', 'n', 't', 'o', 'p', 0 }; 
    inet_ntopFunc = GetSymbolAddress((HANDLE)ws2_32dll, inet_ntop_c);




    char szSeperator[] = { '\t', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '\n', 0 };
    char wszEntryName[] = { '\t', '%', 'S', '\n', 0 };
    char szEntryName[] = { '\t', '%', 's', '\n', 0 };
    char szDoubleNewLine[] = { '\n','\n', 0 };
    char szNewLine[] = { '\n', 0 };
    char wszRecordName[] = { '\t', 'R', 'e', 'c', 'o', 'r', 'd', ' ', 'N', 'a', 'm', 'e', ':', ' ', '%', 'S', '\n', 0 };
    //char wRecordType[] = { '\t', 'R', 'e', 'c', 'o', 'r', 'd', ' ', 'T', 'y', 'p', 'e', ':', ' ', '%', 'd', '\n', 0 };
    char szARecord[] = { '\t', 'A', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 's', '\n', 0 };
    char wszAAAARecord[] = { '\t', 'A', 'A', 'A', 'A', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 's', '\n', 0 };
    char wszNSRecord[] = { '\t', 'N', 'S', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 'S', '\n', 0 };
    char wszCNAMERecord[] = { '\t', 'C','N','A','M','E', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 'S', '\n', 0 };
    char wszPTRRecord[] = { '\t', 'P','T','R', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 'S', '\n', 0 };
    char wszSRVRecord[] = { '\t', 'S','R','V', ' ', 'R', 'e', 'c', 'o', 'r', 'd', ':', ' ', '%', 'S', '\n', 0 };
    char szNoRecord[] = { '\t', 'N','o', ' ', 'R', 'e', 'c', 'o', 'r', 'd', '\n', 0 };
    char szErrorRecord[] = { '\t', 'E','r','r','o','r', ' ', 'R', 'e', 'c', 'o', 'r', 'd', '\n', 0 };
    char szBeaconOutTest[] = { 'B', 'E', 'A', 'C', 'O', 'N', '_', 'O', 'U', 'T', '_', 'T', 'E', 'S', 'T', '\n', 0 };

    char szBuffer[60] = { 0 };

    PDNS_CACHE_ENTRY pEntry = (PDNS_CACHE_ENTRY)((CALLOC)callocFunc)(1, sizeof(DNS_CACHE_ENTRY));
    PDNS_CACHE_ENTRY pThisEntry = (PDNS_CACHE_ENTRY)((CALLOC)callocFunc)(1, sizeof(DNS_CACHE_ENTRY));
    PDNS_CACHE_ENTRY pNextEntry = (PDNS_CACHE_ENTRY)((CALLOC)callocFunc)(1, sizeof(DNS_CACHE_ENTRY));
    
    IN_ADDR Addr4;
    IN6_ADDR Addr6;

    PDNS_RECORDW pQueryResults = NULL, pThisRecord, pNextRecord;
    DNS_STATUS Status;

    ((DNSGETCACHEDATATABLE)dnsgetcachedatatableFunc)(pEntry);
    
    if (pEntry == NULL)
        return;

    pThisEntry = pEntry;
    while (pThisEntry != NULL) 
    {

        pNextEntry = pThisEntry->pNext;

        if ((pThisEntry->wType1 == 0) && (pThisEntry->wType2 == 0))
        {
            goto next;
        }

        Status = ((DNSQUERY_W)dnsquery_wFunc)(pThisEntry->pszName, pThisEntry->wType1, DNS_QUERY_NO_WIRE_QUERY, NULL,(PDNS_RECORD*)&pQueryResults, NULL);

        pThisRecord = pQueryResults;
        
        ((PRINTF)(printfFunc))(wszEntryName,pThisEntry->pszName);
        ((PRINTF)(printfFunc))(szSeperator);
        if (Status == DNS_INFO_NO_RECORDS)
        {
            ((PRINTF)(printfFunc))(szNoRecord);
            goto next;
        }

        if (Status ==  DNS_ERROR_RCODE_NAME_ERROR)
        {
            ((PRINTF)(printfFunc))(szErrorRecord);
            goto next;
        }
            
    
        while (pThisRecord != NULL)
        {

            pNextRecord = pThisRecord->pNext;

            ((PRINTF)(printfFunc))(wszRecordName,pThisRecord->pName);
            //((PRINTF)(printfFunc))(wRecordType,pThisRecord->wType);

            if (pThisEntry->wType1 == DNS_TYPE_A)
            {
                Addr4.S_un.S_addr = pThisRecord->Data.A.IpAddress;
                ((PRINTF)(printfFunc))(szARecord,((INETNTOA)inet_ntoaFunc)(Addr4));
                //PRINT(szEntryName, szBeaconOutTest);
                goto next;
                
            }
            if (pThisEntry->wType1 == DNS_TYPE_AAAA)
            {
                ((MEMCPY)(memcpyFunc))(&Addr6,&pThisRecord->Data.AAAA.Ip6Address, sizeof(IN6_ADDR));
                ((INETNTOP)(inet_ntopFunc))(23,&Addr6, szBuffer, sizeof(szBuffer));
                ((PRINTF)(printfFunc))(wszAAAARecord,szBuffer);
                goto next;                               
            }
            if (pThisEntry->wType1 == DNS_TYPE_NS)
            {
                ((PRINTF)(printfFunc))(wszNSRecord,pThisRecord->Data.NS.pNameHost);
                goto next;
   
            }
            if (pThisEntry->wType1 == DNS_TYPE_CNAME)
            {
                ((PRINTF)(printfFunc))(wszCNAMERecord,pThisRecord->Data.CNAME.pNameHost);
                goto next;
      
            }
            if (pThisEntry->wType1 == DNS_TYPE_PTR)
            {
                ((PRINTF)(printfFunc))(wszPTRRecord,pThisRecord->Data.PTR.pNameHost);
                goto next;
  
            }
            if (pThisEntry->wType1 == DNS_TYPE_SRV)
            {
                ((PRINTF)(printfFunc))(wszSRVRecord,pThisRecord->Data.SRV.pNameTarget);   
                goto next; 
            }  
 
            next: 

            ((PRINTF)(printfFunc))(szNewLine);   

            pThisRecord = pNextRecord;

        }
        
        pThisEntry = pNextEntry;
        ((DNSRECORDLISTFREE)dnsrecordlistfreeFunc)((PDNS_RECORD)pQueryResults, DnsFreeRecordList);
        ((PRINTF)(printfFunc))(szDoubleNewLine);

    }

}


